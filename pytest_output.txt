============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.2, pluggy-1.6.0
Using --randomly-seed=425073868
rootdir: /app
configfile: pyproject.toml
plugins: anyio-4.11.0, xdist-3.8.0, asyncio-1.2.0, cov-7.0.0, randomly-4.0.1
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
created: 4/4 workers
4 workers [19487 items]

.....................................................................F.. [  0%]
.......s..............s...F............................................. [  0%]
......F........................................................F........ [  1%]
........F...............................F............................... [  1%]
....F...................................F..............F................ [  1%]
..................................F..................................... [  2%]
............F........................................................... [  2%]
..........................F............................................. [  2%]
.F.....s......................................F......................F.. [  3%]
.......F..............................F................................. [  3%]
...........................................F............................ [  4%]
........F...s...................s..........................F............ [  4%]
..........................s.s.........................F................. [  4%]
....................F.....................................F............. [  5%]
........................F............................................... [  5%]
....F................................................................... [  5%]
..........................................F.......F..................... [  6%]
......F.....................F.............F............................. [  6%]
.....................................................F....F...s...FF.... [  7%]
......................F..F.....F...........F...Fs......................F [  7%]
.......F...............................F...............F.....F..F......F [  7%]
.....F..F....F.......................................................... [  8%]
....F......s....F....................................................... [  8%]
........................................................................ [  8%]
........................................................................ [  9%]
........................................................................ [  9%]
........................................................................ [  9%]
........................................................................ [ 10%]
........................................................................ [ 10%]
........................................................................ [ 11%]
........................................................................ [ 11%]
........................................................................ [ 11%]
........................................................................ [ 12%]
........................................................................ [ 12%]
........................................................................ [ 12%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
....................................................F................... [ 22%]
......s................................F...s............................ [ 22%]
.........F......F..............F...................................FF... [ 23%]
...........s.F............F............................................. [ 23%]
..F..............F.....F....s.F.....F.........................F..F...... [ 24%]
.........................s...................F...............F.......... [ 24%]
.........................F......F............F.F..F..................... [ 24%]
.......FF...F.F......FF..s....FF........................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 37%]
........................................................................ [ 37%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 41%]
........................................................................ [ 41%]
..........X.X..........................X..........X..................... [ 41%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 45%]
........................................................................ [ 45%]
..............................................................X...X..... [ 45%]
X....X.................................................................. [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 48%]
........................................................................ [ 48%]
........................................................................ [ 48%]
........................................................................ [ 49%]
........................................................................ [ 49%]
........................................................................ [ 49%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 53%]
........................................................................ [ 53%]
........................................................................ [ 53%]
........................................................................ [ 54%]
........................................................................ [ 54%]
........................................................................ [ 55%]
........................................................................ [ 55%]
........................................................................ [ 55%]
........................................................................ [ 56%]
........................................................................ [ 56%]
........................................................................ [ 56%]
........................................................................ [ 57%]
........................................................................ [ 57%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 61%]
........................................................................ [ 61%]
........................................................................ [ 62%]
........................................................................ [ 62%]
........................................................................ [ 62%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 76%]
........................................................................ [ 76%]
........................................................................ [ 76%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 87%]
........................................................................ [ 87%]
........................................................................ [ 87%]
........................................................................ [ 88%]
........................................................................ [ 88%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 90%]
........................................................................ [ 90%]
........................................................................ [ 90%]
........................................................................ [ 91%]
........................................................................ [ 91%]
........................................................................ [ 91%]
........................................................................ [ 92%]
........................................................................ [ 92%]
........................................................................ [ 93%]
........................................................................ [ 93%]
........................................................................ [ 93%]
........................................................................ [ 94%]
........................................................................ [ 94%]
........................................................................ [ 94%]
........................................................................ [ 95%]
........................................................................ [ 95%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
...............................................                          [100%]
=================================== FAILURES ===================================
____ test_json_test_data_coverage[mod_spec72-InsertStrategy-InsertStrategy] ____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'InsertStrategy'
cls = <class 'cirq.circuits.insert_strategy.InsertStrategy'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'InsertStrategy' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/InsertStrategy.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/InsertStrategy.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test InsertStrategy value or list of such values. To get this to work you may need to implement a __repr__ method for InsertStrategy. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add InsertStrategy to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to InsertStrategy. In some cases you will also need to add a _from_json_dict_ class method to the InsertStrategy class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec116-PauliSumExponential-PauliSumExponential] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PauliSumExponential'
cls = <class 'cirq.ops.pauli_sum_exponential.PauliSumExponential'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'PauliSumExponential' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/PauliSumExponential.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/PauliSumExponential.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test PauliSumExponential value or list of such values. To get this to work you may need to implement a __repr__ method for PauliSumExponential. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add PauliSumExponential to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to PauliSumExponential. In some cases you will also need to add a _from_json_dict_ class method to the PauliSumExponential class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
______ test_type_serialization[mod_spec72-InsertStrategy-InsertStrategy] _______
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'InsertStrategy'
cls = <class 'cirq.circuits.insert_strategy.InsertStrategy'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'InsertStrategy'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'InsertStrategy' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec29-CircuitDiagramInfoArgs-CircuitDiagramInfoArgs] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitDiagramInfoArgs'
cls = <class 'cirq.protocols.circuit_diagram_info_protocol.CircuitDiagramInfoArgs'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'CircuitDiagramInfoArgs' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/CircuitDiagramInfoArgs.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/CircuitDiagramInfoArgs.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test CircuitDiagramInfoArgs value or list of such values. To get this to work you may need to implement a __repr__ method for CircuitDiagramInfoArgs. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add CircuitDiagramInfoArgs to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to CircuitDiagramInfoArgs. In some cases you will also need to add a _from_json_dict_ class method to the CircuitDiagramInfoArgs class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec5-AxisAngleDecomposition-AxisAngleDecomposition] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'AxisAngleDecomposition'
cls = <class 'cirq.linalg.decompositions.AxisAngleDecomposition'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'AxisAngleDecomposition' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/AxisAngleDecomposition.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/AxisAngleDecomposition.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test AxisAngleDecomposition value or list of such values. To get this to work you may need to implement a __repr__ method for AxisAngleDecomposition. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add AxisAngleDecomposition to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to AxisAngleDecomposition. In some cases you will also need to add a _from_json_dict_ class method to the AxisAngleDecomposition class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec281-IonQSerializerMixedGatesetsException-IonQSerializerMixedGatesetsException] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQSerializerMixedGatesetsException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQSerializerMixedGatesetsException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'IonQSerializerMixedGatesetsException'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'IonQSerializerMixedGatesetsException' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_________ test_type_serialization[mod_spec274-Calibration-Calibration] _________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'Calibration'
cls = <class 'cirq_ionq.calibration.Calibration'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
E       AssertionError: assert SerializableT...Calibration'>) == SerializableT...Calibration'>)
E
E         Differing attributes:
E         ['test_type']
E
E         Drill down into differing attribute test_type:
E           test_type: <class 'cirq_google.engine.calibration.Calibration'> != <class 'cirq_ionq.calibration.Calibration'>

cirq-core/cirq/protocols/json_serialization_test.py:555: AssertionError
_________ test_json_test_data_coverage[mod_spec0-Alignment-Alignment] __________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'Alignment', cls = <enum 'Alignment'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Alignment' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/Alignment.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/Alignment.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Alignment value or list of such values. To get this to work you may need to implement a __repr__ method for Alignment. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Alignment to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Alignment. In some cases you will also need to add a _from_json_dict_ class method to the Alignment class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec280-IonQNotFoundException-IonQNotFoundException] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQNotFoundException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQNotFoundException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'IonQNotFoundException'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'IonQNotFoundException' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
___ test_type_serialization[mod_spec171-TextDiagramDrawer-TextDiagramDrawer] ___
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'TextDiagramDrawer'
cls = <class 'cirq.circuits.text_diagram_drawer.TextDiagramDrawer'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'TextDiagramDrawer'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'TextDiagramDrawer' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
____ test_json_test_data_coverage[mod_spec279-IonQException-IonQException] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'IonQException' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQException.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQException.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test IonQException value or list of such values. To get this to work you may need to implement a __repr__ method for IonQException. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add IonQException to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to IonQException. In some cases you will also need to add a _from_json_dict_ class method to the IonQException class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec158-SparseSimulatorStep-SparseSimulatorStep] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SparseSimulatorStep'
cls = <class 'cirq.sim.sparse_simulator.SparseSimulatorStep'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'SparseSimulatorStep'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'SparseSimulatorStep' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec87-LinearCombinationOfOperations-LinearCombinationOfOperations] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'LinearCombinationOfOperations'
cls = <class 'cirq.ops.linear_combinations.LinearCombinationOfOperations'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'LinearCombinationOfOperations'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'LinearCombinationOfOperations' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_____ test_type_serialization[mod_spec288-SimulatorResult-SimulatorResult] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'SimulatorResult'
cls = <class 'cirq_ionq.results.SimulatorResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'SimulatorResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'SimulatorResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_______ test_json_test_data_coverage[mod_spec137-QubitOrder-QubitOrder] ________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QubitOrder'
cls = <class 'cirq.ops.qubit_order.QubitOrder'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'QubitOrder' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/QubitOrder.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/QubitOrder.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test QubitOrder value or list of such values. To get this to work you may need to implement a __repr__ method for QubitOrder. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add QubitOrder to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to QubitOrder. In some cases you will also need to add a _from_json_dict_ class method to the QubitOrder class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec44-DensityMatrixSimulator-DensityMatrixSimulator] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixSimulator'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixSimulator'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'DensityMatrixSimulator' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixSimulator.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixSimulator.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test DensityMatrixSimulator value or list of such values. To get this to work you may need to implement a __repr__ method for DensityMatrixSimulator. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add DensityMatrixSimulator to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to DensityMatrixSimulator. In some cases you will also need to add a _from_json_dict_ class method to the DensityMatrixSimulator class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
__________ test_type_serialization[mod_spec137-QubitOrder-QubitOrder] __________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QubitOrder'
cls = <class 'cirq.ops.qubit_order.QubitOrder'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'QubitOrder'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'QubitOrder' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec46-DensityMatrixTrialResult-DensityMatrixTrialResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixTrialResult'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'DensityMatrixTrialResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'DensityMatrixTrialResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_______ test_json_test_data_coverage[mod_spec246-Sycamore23-GridDevice] ________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_google, cirq_obj_name = 'Sycamore23'
cls = <class 'cirq_google.devices.grid_device.GridDevice'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Sycamore23' in the module 'cirq_google' that does not have associated test data.
E
E           You must create the file
E               cirq-google/cirq_google/json_test_data/Sycamore23.json
E           and the file
E               cirq-google/cirq_google/json_test_data/Sycamore23.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Sycamore23 value or list of such values. To get this to work you may need to implement a __repr__ method for Sycamore23. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Sycamore23 to the `_class_resolver_dictionary` method in the cirq_google/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Sycamore23. In some cases you will also need to add a _from_json_dict_ class method to the Sycamore23 class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-google/cirq_google/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
__ test_type_serialization[mod_spec28-CircuitDiagramInfo-CircuitDiagramInfo] ___
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitDiagramInfo'
cls = <class 'cirq.protocols.circuit_diagram_info_protocol.CircuitDiagramInfo'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'CircuitDiagramInfo'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'CircuitDiagramInfo' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec171-TextDiagramDrawer-TextDiagramDrawer] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'TextDiagramDrawer'
cls = <class 'cirq.circuits.text_diagram_drawer.TextDiagramDrawer'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'TextDiagramDrawer' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/TextDiagramDrawer.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/TextDiagramDrawer.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test TextDiagramDrawer value or list of such values. To get this to work you may need to implement a __repr__ method for TextDiagramDrawer. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add TextDiagramDrawer to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to TextDiagramDrawer. In some cases you will also need to add a _from_json_dict_ class method to the TextDiagramDrawer class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec45-DensityMatrixStepResult-DensityMatrixStepResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixStepResult'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixStepResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'DensityMatrixStepResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixStepResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixStepResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test DensityMatrixStepResult value or list of such values. To get this to work you may need to implement a __repr__ method for DensityMatrixStepResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add DensityMatrixStepResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to DensityMatrixStepResult. In some cases you will also need to add a _from_json_dict_ class method to the DensityMatrixStepResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
___________ test_type_serialization[mod_spec286-QPUResult-QPUResult] ___________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'QPUResult'
cls = <class 'cirq_ionq.results.QPUResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'QPUResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'QPUResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec163-StateVectorTrialResult-StateVectorTrialResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'StateVectorTrialResult'
cls = <class 'cirq.sim.state_vector_simulator.StateVectorTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'StateVectorTrialResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'StateVectorTrialResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
____ test_json_test_data_coverage[mod_spec117-PeriodicValue-PeriodicValue] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PeriodicValue'
cls = <class 'cirq.value.periodic_value.PeriodicValue'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'PeriodicValue' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/PeriodicValue.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/PeriodicValue.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test PeriodicValue value or list of such values. To get this to work you may need to implement a __repr__ method for PeriodicValue. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add PeriodicValue to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to PeriodicValue. In some cases you will also need to add a _from_json_dict_ class method to the PeriodicValue class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
____ test_json_test_data_coverage[mod_spec278-IonQAPIDevice-IonQAPIDevice] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQAPIDevice'
cls = <class 'cirq_ionq.ionq_devices.IonQAPIDevice'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'IonQAPIDevice' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQAPIDevice.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQAPIDevice.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test IonQAPIDevice value or list of such values. To get this to work you may need to implement a __repr__ method for IonQAPIDevice. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add IonQAPIDevice to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to IonQAPIDevice. In some cases you will also need to add a _from_json_dict_ class method to the IonQAPIDevice class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec153-SimulationTrialResult-SimulationTrialResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SimulationTrialResult'
cls = <class 'cirq.sim.simulator.SimulationTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'SimulationTrialResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'SimulationTrialResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec46-DensityMatrixTrialResult-DensityMatrixTrialResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixTrialResult'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'DensityMatrixTrialResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixTrialResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/DensityMatrixTrialResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test DensityMatrixTrialResult value or list of such values. To get this to work you may need to implement a __repr__ method for DensityMatrixTrialResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add DensityMatrixTrialResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to DensityMatrixTrialResult. In some cases you will also need to add a _from_json_dict_ class method to the DensityMatrixTrialResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec38-CliffordTrialResult-CliffordTrialResult] __
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CliffordTrialResult'
cls = <class 'cirq.sim.clifford.clifford_simulator.CliffordTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'CliffordTrialResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'CliffordTrialResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_____ test_json_test_data_coverage[mod_spec51-ExpressionMap-ExpressionMap] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'ExpressionMap'
cls = <class 'cirq.study.flatten_expressions.ExpressionMap'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'ExpressionMap' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/ExpressionMap.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/ExpressionMap.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test ExpressionMap value or list of such values. To get this to work you may need to implement a __repr__ method for ExpressionMap. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add ExpressionMap to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to ExpressionMap. In some cases you will also need to add a _from_json_dict_ class method to the ExpressionMap class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
____ test_type_serialization[mod_spec31-CircuitSampleJob-CircuitSampleJob] _____
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitSampleJob'
cls = <class 'cirq.work.collector.CircuitSampleJob'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'CircuitSampleJob'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'CircuitSampleJob' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_______ test_type_serialization[mod_spec117-PeriodicValue-PeriodicValue] _______
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PeriodicValue'
cls = <class 'cirq.value.periodic_value.PeriodicValue'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'PeriodicValue'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'PeriodicValue' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec125-PointOptimizationSummary-PointOptimizationSummary] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PointOptimizationSummary'
cls = <class 'cirq.circuits.optimization_pass.PointOptimizationSummary'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'PointOptimizationSummary' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/PointOptimizationSummary.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/PointOptimizationSummary.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test PointOptimizationSummary value or list of such values. To get this to work you may need to implement a __repr__ method for PointOptimizationSummary. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add PointOptimizationSummary to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to PointOptimizationSummary. In some cases you will also need to add a _from_json_dict_ class method to the PointOptimizationSummary class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_______ test_type_serialization[mod_spec51-ExpressionMap-ExpressionMap] ________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'ExpressionMap'
cls = <class 'cirq.study.flatten_expressions.ExpressionMap'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'ExpressionMap'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'ExpressionMap' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_________ test_json_test_data_coverage[mod_spec132-QasmArgs-QasmArgs] __________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QasmArgs'
cls = <class 'cirq.protocols.qasm.QasmArgs'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'QasmArgs' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/QasmArgs.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/QasmArgs.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test QasmArgs value or list of such values. To get this to work you may need to implement a __repr__ method for QasmArgs. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add QasmArgs to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to QasmArgs. In some cases you will also need to add a _from_json_dict_ class method to the QasmArgs class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec115-PauliSumCollector-PauliSumCollector] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PauliSumCollector'
cls = <class 'cirq.work.pauli_sum_collector.PauliSumCollector'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'PauliSumCollector' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/PauliSumCollector.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/PauliSumCollector.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test PauliSumCollector value or list of such values. To get this to work you may need to implement a __repr__ method for PauliSumCollector. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add PauliSumCollector to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to PauliSumCollector. In some cases you will also need to add a _from_json_dict_ class method to the PauliSumCollector class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
______________ test_json_test_data_coverage[mod_spec284-Job-Job] _______________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'Job', cls = <class 'cirq_ionq.job.Job'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Job' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/Job.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/Job.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Job value or list of such values. To get this to work you may need to implement a __repr__ method for Job. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Job to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Job. In some cases you will also need to add a _from_json_dict_ class method to the Job class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec35-CliffordSimulatorStepResult-CliffordSimulatorStepResult] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CliffordSimulatorStepResult'
cls = <class 'cirq.sim.clifford.clifford_simulator.CliffordSimulatorStepResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'CliffordSimulatorStepResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'CliffordSimulatorStepResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_______ test_type_serialization[mod_spec278-IonQAPIDevice-IonQAPIDevice] _______
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQAPIDevice'
cls = <class 'cirq_ionq.ionq_devices.IonQAPIDevice'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'IonQAPIDevice'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'IonQAPIDevice' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
________ test_json_test_data_coverage[mod_spec175-Timestamp-Timestamp] _________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'Timestamp'
cls = <class 'cirq.value.timestamp.Timestamp'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Timestamp' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/Timestamp.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/Timestamp.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Timestamp value or list of such values. To get this to work you may need to implement a __repr__ method for Timestamp. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Timestamp to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Timestamp. In some cases you will also need to add a _from_json_dict_ class method to the Timestamp class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
____________ test_type_serialization[mod_spec132-QasmArgs-QasmArgs] ____________
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QasmArgs'
cls = <class 'cirq.protocols.qasm.QasmArgs'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'QasmArgs'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'QasmArgs' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec28-CircuitDiagramInfo-CircuitDiagramInfo] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitDiagramInfo'
cls = <class 'cirq.protocols.circuit_diagram_info_protocol.CircuitDiagramInfo'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'CircuitDiagramInfo' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/CircuitDiagramInfo.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/CircuitDiagramInfo.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test CircuitDiagramInfo value or list of such values. To get this to work you may need to implement a __repr__ method for CircuitDiagramInfo. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add CircuitDiagramInfo to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to CircuitDiagramInfo. In some cases you will also need to add a _from_json_dict_ class method to the CircuitDiagramInfo class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec281-IonQSerializerMixedGatesetsException-IonQSerializerMixedGatesetsException] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQSerializerMixedGatesetsException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQSerializerMixedGatesetsException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'IonQSerializerMixedGatesetsException' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQSerializerMixedGatesetsException.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQSerializerMixedGatesetsException.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test IonQSerializerMixedGatesetsException value or list of such values. To get this to work you may need to implement a __repr__ method for IonQSerializerMixedGatesetsException. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add IonQSerializerMixedGatesetsException to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to IonQSerializerMixedGatesetsException. In some cases you will also need to add a _from_json_dict_ class method to the IonQSerializerMixedGatesetsException class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec162-StateVectorMixin-StateVectorMixin] __
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'StateVectorMixin'
cls = <class 'cirq.sim.state_vector.StateVectorMixin'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'StateVectorMixin' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/StateVectorMixin.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/StateVectorMixin.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test StateVectorMixin value or list of such values. To get this to work you may need to implement a __repr__ method for StateVectorMixin. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add StateVectorMixin to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to StateVectorMixin. In some cases you will also need to add a _from_json_dict_ class method to the StateVectorMixin class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec158-SparseSimulatorStep-SparseSimulatorStep] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SparseSimulatorStep'
cls = <class 'cirq.sim.sparse_simulator.SparseSimulatorStep'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'SparseSimulatorStep' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/SparseSimulatorStep.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/SparseSimulatorStep.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test SparseSimulatorStep value or list of such values. To get this to work you may need to implement a __repr__ method for SparseSimulatorStep. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add SparseSimulatorStep to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to SparseSimulatorStep. In some cases you will also need to add a _from_json_dict_ class method to the SparseSimulatorStep class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec280-IonQNotFoundException-IonQNotFoundException] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQNotFoundException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQNotFoundException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'IonQNotFoundException' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQNotFoundException.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQNotFoundException.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test IonQNotFoundException value or list of such values. To get this to work you may need to implement a __repr__ method for IonQNotFoundException. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add IonQNotFoundException to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to IonQNotFoundException. In some cases you will also need to add a _from_json_dict_ class method to the IonQNotFoundException class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec125-PointOptimizationSummary-PointOptimizationSummary] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PointOptimizationSummary'
cls = <class 'cirq.circuits.optimization_pass.PointOptimizationSummary'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'PointOptimizationSummary'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'PointOptimizationSummary' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
__ test_json_test_data_coverage[mod_spec80-KakDecomposition-KakDecomposition] __
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'KakDecomposition'
cls = <class 'cirq.linalg.decompositions.KakDecomposition'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'KakDecomposition' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/KakDecomposition.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/KakDecomposition.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test KakDecomposition value or list of such values. To get this to work you may need to implement a __repr__ method for KakDecomposition. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add KakDecomposition to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to KakDecomposition. In some cases you will also need to add a _from_json_dict_ class method to the KakDecomposition class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec44-DensityMatrixSimulator-DensityMatrixSimulator] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixSimulator'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixSimulator'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'DensityMatrixSimulator'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'DensityMatrixSimulator' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec5-AxisAngleDecomposition-AxisAngleDecomposition] _
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'AxisAngleDecomposition'
cls = <class 'cirq.linalg.decompositions.AxisAngleDecomposition'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'AxisAngleDecomposition'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7fbca88d6de0>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7fbc88377420>, <function _lazy_resolver.<locals>.json_resolver at 0x7fbc89453c40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'AxisAngleDecomposition' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_____ test_json_test_data_coverage[mod_spec136-QuantumState-QuantumState] ______
[gw2] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QuantumState'
cls = <class 'cirq.qis.states.QuantumState'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'QuantumState' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/QuantumState.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/QuantumState.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test QuantumState value or list of such values. To get this to work you may need to implement a __repr__ method for QuantumState. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add QuantumState to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to QuantumState. In some cases you will also need to add a _from_json_dict_ class method to the QuantumState class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
__ test_json_test_data_coverage[mod_spec31-CircuitSampleJob-CircuitSampleJob] __
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitSampleJob'
cls = <class 'cirq.work.collector.CircuitSampleJob'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'CircuitSampleJob' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/CircuitSampleJob.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/CircuitSampleJob.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test CircuitSampleJob value or list of such values. To get this to work you may need to implement a __repr__ method for CircuitSampleJob. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add CircuitSampleJob to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to CircuitSampleJob. In some cases you will also need to add a _from_json_dict_ class method to the CircuitSampleJob class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec29-CircuitDiagramInfoArgs-CircuitDiagramInfoArgs] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CircuitDiagramInfoArgs'
cls = <class 'cirq.protocols.circuit_diagram_info_protocol.CircuitDiagramInfoArgs'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'CircuitDiagramInfoArgs'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'CircuitDiagramInfoArgs' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
___ test_type_serialization[mod_spec115-PauliSumCollector-PauliSumCollector] ___
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PauliSumCollector'
cls = <class 'cirq.work.pauli_sum_collector.PauliSumCollector'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'PauliSumCollector'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'PauliSumCollector' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec87-LinearCombinationOfOperations-LinearCombinationOfOperations] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'LinearCombinationOfOperations'
cls = <class 'cirq.ops.linear_combinations.LinearCombinationOfOperations'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'LinearCombinationOfOperations' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/LinearCombinationOfOperations.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/LinearCombinationOfOperations.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test LinearCombinationOfOperations value or list of such values. To get this to work you may need to implement a __repr__ method for LinearCombinationOfOperations. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add LinearCombinationOfOperations to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to LinearCombinationOfOperations. In some cases you will also need to add a _from_json_dict_ class method to the LinearCombinationOfOperations class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
___________ test_type_serialization[mod_spec175-Timestamp-Timestamp] ___________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'Timestamp'
cls = <class 'cirq.value.timestamp.Timestamp'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'Timestamp'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'Timestamp' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_______ test_json_test_data_coverage[mod_spec133-QasmOutput-QasmOutput] ________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QasmOutput'
cls = <class 'cirq.circuits.qasm_output.QasmOutput'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'QasmOutput' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/QasmOutput.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/QasmOutput.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test QasmOutput value or list of such values. To get this to work you may need to implement a __repr__ method for QasmOutput. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add QasmOutput to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to QasmOutput. In some cases you will also need to add a _from_json_dict_ class method to the QasmOutput class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
__________ test_type_serialization[mod_spec133-QasmOutput-QasmOutput] __________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QasmOutput'
cls = <class 'cirq.circuits.qasm_output.QasmOutput'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'QasmOutput'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'QasmOutput' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
__ test_json_test_data_coverage[mod_spec288-SimulatorResult-SimulatorResult] ___
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'SimulatorResult'
cls = <class 'cirq_ionq.results.SimulatorResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'SimulatorResult' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/SimulatorResult.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/SimulatorResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test SimulatorResult value or list of such values. To get this to work you may need to implement a __repr__ method for SimulatorResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add SimulatorResult to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to SimulatorResult. In some cases you will also need to add a _from_json_dict_ class method to the SimulatorResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec179-TwoQubitGateTabulationResult-TwoQubitGateTabulationResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'TwoQubitGateTabulationResult'
cls = <class 'cirq.transformers.heuristic_decompositions.two_qubit_gate_tabulation.TwoQubitGateTabulationResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'TwoQubitGateTabulationResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'TwoQubitGateTabulationResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec86-LinearCombinationOfGates-LinearCombinationOfGates] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'LinearCombinationOfGates'
cls = <class 'cirq.ops.linear_combinations.LinearCombinationOfGates'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'LinearCombinationOfGates' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/LinearCombinationOfGates.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/LinearCombinationOfGates.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test LinearCombinationOfGates value or list of such values. To get this to work you may need to implement a __repr__ method for LinearCombinationOfGates. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add LinearCombinationOfGates to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to LinearCombinationOfGates. In some cases you will also need to add a _from_json_dict_ class method to the LinearCombinationOfGates class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_______ test_type_serialization[mod_spec279-IonQException-IonQException] _______
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'IonQException'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'IonQException' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec283-IonQUnsuccessfulJobException-IonQUnsuccessfulJobException] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQUnsuccessfulJobException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQUnsuccessfulJobException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'IonQUnsuccessfulJobException' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQUnsuccessfulJobException.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/IonQUnsuccessfulJobException.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test IonQUnsuccessfulJobException value or list of such values. To get this to work you may need to implement a __repr__ method for IonQUnsuccessfulJobException. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add IonQUnsuccessfulJobException to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to IonQUnsuccessfulJobException. In some cases you will also need to add a _from_json_dict_ class method to the IonQUnsuccessfulJobException class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec153-SimulationTrialResult-SimulationTrialResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SimulationTrialResult'
cls = <class 'cirq.sim.simulator.SimulationTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'SimulationTrialResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/SimulationTrialResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/SimulationTrialResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test SimulationTrialResult value or list of such values. To get this to work you may need to implement a __repr__ method for SimulationTrialResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add SimulationTrialResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to SimulationTrialResult. In some cases you will also need to add a _from_json_dict_ class method to the SimulationTrialResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
____ test_type_serialization[mod_spec80-KakDecomposition-KakDecomposition] _____
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'KakDecomposition'
cls = <class 'cirq.linalg.decompositions.KakDecomposition'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'KakDecomposition'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'KakDecomposition' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec154-SimulationTrialResultBase-SimulationTrialResultBase] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SimulationTrialResultBase'
cls = <class 'cirq.sim.simulator_base.SimulationTrialResultBase'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'SimulationTrialResultBase'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'SimulationTrialResultBase' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec35-CliffordSimulatorStepResult-CliffordSimulatorStepResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CliffordSimulatorStepResult'
cls = <class 'cirq.sim.clifford.clifford_simulator.CliffordSimulatorStepResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'CliffordSimulatorStepResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/CliffordSimulatorStepResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/CliffordSimulatorStepResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test CliffordSimulatorStepResult value or list of such values. To get this to work you may need to implement a __repr__ method for CliffordSimulatorStepResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add CliffordSimulatorStepResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to CliffordSimulatorStepResult. In some cases you will also need to add a _from_json_dict_ class method to the CliffordSimulatorStepResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec116-PauliSumExponential-PauliSumExponential] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'PauliSumExponential'
cls = <class 'cirq.ops.pauli_sum_exponential.PauliSumExponential'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'PauliSumExponential'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'PauliSumExponential' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec45-DensityMatrixStepResult-DensityMatrixStepResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'DensityMatrixStepResult'
cls = <class 'cirq.sim.density_matrix_simulator.DensityMatrixStepResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'DensityMatrixStepResult'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'DensityMatrixStepResult' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
____ test_type_serialization[mod_spec162-StateVectorMixin-StateVectorMixin] ____
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'StateVectorMixin'
cls = <class 'cirq.sim.state_vector.StateVectorMixin'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'StateVectorMixin'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'StateVectorMixin' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
________ test_json_test_data_coverage[mod_spec245-Sycamore-GridDevice] _________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_google, cirq_obj_name = 'Sycamore'
cls = <class 'cirq_google.devices.grid_device.GridDevice'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Sycamore' in the module 'cirq_google' that does not have associated test data.
E
E           You must create the file
E               cirq-google/cirq_google/json_test_data/Sycamore.json
E           and the file
E               cirq-google/cirq_google/json_test_data/Sycamore.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Sycamore value or list of such values. To get this to work you may need to implement a __repr__ method for Sycamore. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Sycamore to the `_class_resolver_dictionary` method in the cirq_google/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Sycamore. In some cases you will also need to add a _from_json_dict_ class method to the Sycamore class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-google/cirq_google/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
______ test_json_test_data_coverage[mod_spec274-Calibration-Calibration] _______
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'Calibration'
cls = <class 'cirq_ionq.calibration.Calibration'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'Calibration' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/Calibration.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/Calibration.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test Calibration value or list of such values. To get this to work you may need to implement a __repr__ method for Calibration. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add Calibration to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to Calibration. In some cases you will also need to add a _from_json_dict_ class method to the Calibration class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec154-SimulationTrialResultBase-SimulationTrialResultBase] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'SimulationTrialResultBase'
cls = <class 'cirq.sim.simulator_base.SimulationTrialResultBase'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'SimulationTrialResultBase' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/SimulationTrialResultBase.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/SimulationTrialResultBase.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test SimulationTrialResultBase value or list of such values. To get this to work you may need to implement a __repr__ method for SimulationTrialResultBase. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add SimulationTrialResultBase to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to SimulationTrialResultBase. In some cases you will also need to add a _from_json_dict_ class method to the SimulationTrialResultBase class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
________ test_type_serialization[mod_spec136-QuantumState-QuantumState] ________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'QuantumState'
cls = <class 'cirq.qis.states.QuantumState'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'QuantumState'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'QuantumState' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_json_test_data_coverage[mod_spec179-TwoQubitGateTabulationResult-TwoQubitGateTabulationResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'TwoQubitGateTabulationResult'
cls = <class 'cirq.transformers.heuristic_decompositions.two_qubit_gate_tabulation.TwoQubitGateTabulationResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'TwoQubitGateTabulationResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/TwoQubitGateTabulationResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/TwoQubitGateTabulationResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test TwoQubitGateTabulationResult value or list of such values. To get this to work you may need to implement a __repr__ method for TwoQubitGateTabulationResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add TwoQubitGateTabulationResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to TwoQubitGateTabulationResult. In some cases you will also need to add a _from_json_dict_ class method to the TwoQubitGateTabulationResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec163-StateVectorTrialResult-StateVectorTrialResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'StateVectorTrialResult'
cls = <class 'cirq.sim.state_vector_simulator.StateVectorTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'StateVectorTrialResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/StateVectorTrialResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/StateVectorTrialResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test StateVectorTrialResult value or list of such values. To get this to work you may need to implement a __repr__ method for StateVectorTrialResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add StateVectorTrialResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to StateVectorTrialResult. In some cases you will also need to add a _from_json_dict_ class method to the StateVectorTrialResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_json_test_data_coverage[mod_spec38-CliffordTrialResult-CliffordTrialResult] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'CliffordTrialResult'
cls = <class 'cirq.sim.clifford.clifford_simulator.CliffordTrialResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'CliffordTrialResult' in the module 'cirq' that does not have associated test data.
E
E           You must create the file
E               cirq-core/cirq/protocols/json_test_data/CliffordTrialResult.json
E           and the file
E               cirq-core/cirq/protocols/json_test_data/CliffordTrialResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test CliffordTrialResult value or list of such values. To get this to work you may need to implement a __repr__ method for CliffordTrialResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add CliffordTrialResult to the `_class_resolver_dictionary` method in the cirq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to CliffordTrialResult. In some cases you will also need to add a _from_json_dict_ class method to the CliffordTrialResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-core/cirq/protocols/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
________ test_json_test_data_coverage[mod_spec286-QPUResult-QPUResult] _________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'QPUResult'
cls = <class 'cirq_ionq.results.QPUResult'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_json_test_data_coverage(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        test_data_path = mod_spec.test_data_path
        rel_path = test_data_path.relative_to(REPO_ROOT)
        mod_path = mod_spec.name.replace(".", "/")
        rel_resolver_cache_path = f"{mod_path}/json_resolver_cache.py"
        json_path = test_data_path / f'{cirq_obj_name}.json'
        json_path2 = test_data_path / f'{cirq_obj_name}.json_inward'
        deprecation_deadline = mod_spec.deprecated.get(cirq_obj_name)

        if not json_path.exists() and not json_path2.exists():  # pragma: no cover
>           pytest.fail(
                f"Hello intrepid developer. There is a new public or "
                f"serializable object named '{cirq_obj_name}' in the module '{mod_spec.name}' "
                f"that does not have associated test data.\n"
                f"\n"
                f"You must create the file\n"
                f"    {rel_path}/{cirq_obj_name}.json\n"
                f"and the file\n"
                f"    {rel_path}/{cirq_obj_name}.repr\n"
                f"in order to guarantee this public object is, and will "
                f"remain, serializable.\n"
                f"\n"
                f"The content of the .repr file should be the string returned "
                f"by `repr(obj)` where `obj` is a test {cirq_obj_name} value "
                f"or list of such values. To get this to work you may need to "
                f"implement a __repr__ method for {cirq_obj_name}. The repr "
                f"must be a parsable python expression that evaluates to "
                f"something equal to `obj`."
                f"\n"
                f"The content of the .json file should be the string returned "
                f"by `cirq.to_json(obj)` where `obj` is the same object or "
                f"list of test objects.\n"
                f"To get this to work you likely need "
                f"to add {cirq_obj_name} to the "
                f"`_class_resolver_dictionary` method in "
                f"the {rel_resolver_cache_path} source file. "
                f"You may also need to add a _json_dict_ method to "
                f"{cirq_obj_name}. In some cases you will also need to add a "
                f"_from_json_dict_ class method to the {cirq_obj_name} class."
                f"\n"
                f"For more information on JSON serialization, please read the "
                f"docstring for cirq.protocols.SupportsJSON. If this object or "
                f"class is not appropriate for serialization, add its name to "
                f"the `should_not_be_serialized` list in the TestSpec defined in the "
                f"{rel_path}/spec.py source file."
            )
E           Failed: Hello intrepid developer. There is a new public or serializable object named 'QPUResult' in the module 'cirq_ionq' that does not have associated test data.
E
E           You must create the file
E               cirq-ionq/cirq_ionq/json_test_data/QPUResult.json
E           and the file
E               cirq-ionq/cirq_ionq/json_test_data/QPUResult.repr
E           in order to guarantee this public object is, and will remain, serializable.
E
E           The content of the .repr file should be the string returned by `repr(obj)` where `obj` is a test QPUResult value or list of such values. To get this to work you may need to implement a __repr__ method for QPUResult. The repr must be a parsable python expression that evaluates to something equal to `obj`.
E           The content of the .json file should be the string returned by `cirq.to_json(obj)` where `obj` is the same object or list of test objects.
E           To get this to work you likely need to add QPUResult to the `_class_resolver_dictionary` method in the cirq_ionq/json_resolver_cache.py source file. You may also need to add a _json_dict_ method to QPUResult. In some cases you will also need to add a _from_json_dict_ class method to the QPUResult class.
E           For more information on JSON serialization, please read the docstring for cirq.protocols.SupportsJSON. If this object or class is not appropriate for serialization, add its name to the `should_not_be_serialized` list in the TestSpec defined in the cirq-ionq/cirq_ionq/json_test_data/spec.py source file.

cirq-core/cirq/protocols/json_serialization_test.py:462: Failed
_ test_type_serialization[mod_spec86-LinearCombinationOfGates-LinearCombinationOfGates] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'LinearCombinationOfGates'
cls = <class 'cirq.ops.linear_combinations.LinearCombinationOfGates'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'LinearCombinationOfGates'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'LinearCombinationOfGates' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_________________ test_type_serialization[mod_spec284-Job-Job] _________________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'Job', cls = <class 'cirq_ionq.job.Job'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'Job'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'Job' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
_ test_type_serialization[mod_spec283-IonQUnsuccessfulJobException-IonQUnsuccessfulJobException] _
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq_ionq, cirq_obj_name = 'IonQUnsuccessfulJobException'
cls = <class 'cirq_ionq.ionq_exceptions.IonQUnsuccessfulJobException'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'IonQUnsuccessfulJobException'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'IonQUnsuccessfulJobException' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
____________ test_type_serialization[mod_spec0-Alignment-Alignment] ____________
[gw1] linux -- Python 3.12.11 /home/jules/.pyenv/versions/3.12.11/bin/python3.12

mod_spec = cirq, cirq_obj_name = 'Alignment', cls = <enum 'Alignment'>

    @pytest.mark.parametrize('mod_spec,cirq_obj_name,cls', _list_public_classes_for_tested_modules())
    def test_type_serialization(mod_spec: ModuleJsonTestSpec, cirq_obj_name: str, cls) -> None:
        if cirq_obj_name in mod_spec.tested_elsewhere:
            pytest.skip("Tested elsewhere.")

        if cirq_obj_name in mod_spec.not_yet_serializable:
            pytest.xfail(reason="Not serializable (yet)")

        if cls is None:
            pytest.skip(f'No serialization for None-mapped type: {cirq_obj_name}')  # pragma: no cover

        try:
            typename = cirq.json_cirq_type(cls)
        except ValueError as e:
            pytest.skip(f'No serialization for non-Cirq type: {str(e)}')

        def custom_resolver(name):
            if name == 'SerializableTypeObject':
                return SerializableTypeObject

        sto = SerializableTypeObject(cls)
        test_resolvers = [custom_resolver] + cirq.DEFAULT_RESOLVERS
        expected_json = f'{{\n  "cirq_type": "SerializableTypeObject",\n  "test_type": "{typename}"\n}}'
        assert cirq.to_json(sto) == expected_json
>       assert cirq.read_json(json_text=expected_json, resolvers=test_resolvers) == sto
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cirq-core/cirq/protocols/json_serialization_test.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cirq-core/cirq/protocols/json_serialization.py:554: in read_json
    return json.loads(json_text, object_hook=obj_hook)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/__init__.py:359: in loads
    return cls(**kw).decode(s)
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:338: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/json/decoder.py:354: in raw_decode
    obj, end = self.scan_once(s, idx)
               ^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:355: in __call__
    return from_json_dict(**d)
           ^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization_test.py:528: in _from_json_dict_
    return cls(json_serialization.cirq_type_from_json(test_type))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cirq-core/cirq/protocols/json_serialization.py:453: in cirq_type_from_json
    cirq_type = factory_from_json(type_str, resolvers)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_str = 'Alignment'
resolvers = [<function _lazy_resolver.<locals>.json_resolver at 0x7facd331de40>, <function _lazy_resolver.<locals>.json_resolver a...resolver.<locals>.json_resolver at 0x7facb2e43420>, <function _lazy_resolver.<locals>.json_resolver at 0x7facb3f1fc40>]

    def factory_from_json(
        type_str: str, resolvers: Sequence[JsonResolver] | None = None
    ) -> ObjectFactory:
        """Returns a factory for constructing objects of type `type_str`.

        DEFAULT_RESOLVERS is updated dynamically as cirq submodules are imported.

        Args:
            type_str: string representation of the type to deserialize.
            resolvers: list of JsonResolvers to use in type resolution. If this is
                left blank, DEFAULT_RESOLVERS will be used.

        Returns:
            An ObjectFactory that can be called to construct an object whose type
            matches the name `type_str`.

        Raises:
            ValueError: if type_str does not have a match in `resolvers`.
        """
        resolvers = resolvers if resolvers is not None else DEFAULT_RESOLVERS
        for resolver in resolvers:
            cirq_type = resolver(type_str)
            if cirq_type is not None:
                return cirq_type
>       raise ValueError(f"Could not resolve type '{type_str}' during deserialization")
E       ValueError: Could not resolve type 'Alignment' during deserialization

cirq-core/cirq/protocols/json_serialization.py:431: ValueError
=============================== warnings summary ===============================
cirq-core/cirq/contrib/routing/greedy_test.py: 1 warning
cirq-core/cirq/experiments/xeb_fitting_test.py: 8 warnings
cirq-core/cirq/experiments/xeb_simulation_test.py: 8 warnings
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/multiprocessing/popen_fork.py:66: DeprecationWarning: This process (pid=22717) is multi-threaded, use of fork() may lead to deadlocks in the child.
    self.pid = os.fork()

cirq-core/cirq/sim/state_vector_simulator_test.py::test_state_vector_trial_result_equality
  /app/cirq-core/cirq/sim/state_vector_simulator.py:134: UserWarning: final state vector's norm=np.float32(0.0) is too far from 1, 1.0 > 0.0003452669770922512.skipping renormalization
    warnings.warn(

cirq-core/cirq/work/observable_measurement_data_test.py::test_bitstring_accumulator_errors
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:4268: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

cirq-core/cirq/work/observable_measurement_data_test.py::test_bitstring_accumulator_errors
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/numpy/_core/_methods.py:214: RuntimeWarning: invalid value encountered in scalar divide
    ret = ret.dtype.type(ret / rcount)

cirq-core/cirq/ops/controlled_gate_test.py::test_controlled_gate_is_consistent[gate16-False]
cirq-core/cirq/ops/dense_pauli_string_test.py::test_protocols
cirq-core/cirq/ops/global_phase_op_test.py::test_protocols
  /app/cirq-core/cirq/study/resolver.py:172: RuntimeWarning: divide by zero encountered in float_power
    return np.float_power(cast(complex, base), cast(complex, exponent))

cirq-core/cirq/experiments/z_phase_calibration_test.py: 64 warnings
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/multiprocessing/popen_fork.py:66: DeprecationWarning: This process (pid=22723) is multi-threaded, use of fork() may lead to deadlocks in the child.
    self.pid = os.fork()

cirq-core/cirq/experiments/single_qubit_readout_calibration_test.py::test_estimate_parallel_readout_errors_no_noise
  /app/cirq-core/cirq/vis/histogram.py:122: UserWarning: Data has no positive values, and therefore cannot be log-scaled.
    set_semilog()

cirq-core/cirq/experiments/single_qubit_readout_calibration_test.py::test_estimate_parallel_readout_errors_no_noise
  /app/cirq-core/cirq/vis/histogram.py:123: UserWarning: Data has no positive values, and therefore cannot be log-scaled.
    set_lim(0, 1)

cirq-core/cirq/experiments/z_phase_calibration_test.py::test_calibrate_z_phases_workflow_no_options[angles2-error2]
cirq-core/cirq/experiments/z_phase_calibration_test.py::test_calibrate_z_phases_workflow_no_options[angles1-error1]
  /app/cirq-core/cirq/experiments/xeb_fitting.py:658: OptimizeWarning: Covariance of the parameters could not be estimated
    (a, layer_fid), pcov = optimize.curve_fit(

cirq-core/cirq/experiments/qubit_characterizations_test.py::test_parallel_single_qubit_randomized_benchmarking_with_noise
  /app/cirq-core/cirq/experiments/qubit_characterizations_test.py:148: DeprecationWarning: parallel_single_qubit_randomized_benchmarking was used but is deprecated.
  It will be removed in cirq v2.0.
  please use parallel_single_qubit_rb instead

    results = parallel_single_qubit_randomized_benchmarking(

cirq-core/cirq/experiments/qubit_characterizations_test.py::test_parallel_single_qubit_randomized_benchmarking_with_noise
cirq-core/cirq/experiments/qubit_characterizations_test.py::test_parallel_single_qubit_parallel_single_qubit_randomized_benchmarking
  /app/cirq-core/cirq/experiments/qubit_characterizations.py:157: OptimizeWarning: Covariance of the parameters could not be estimated
    return curve_fit(

cirq-core/cirq/experiments/qubit_characterizations_test.py::test_single_qubit_randomized_benchmarking
  /app/cirq-core/cirq/experiments/qubit_characterizations_test.py:117: DeprecationWarning: single_qubit_randomized_benchmarking was used but is deprecated.
  It will be removed in cirq v2.0.
  please use single_qubit_rb instead

    results = single_qubit_randomized_benchmarking(simulator, qubit, num_clifford_range=num_cfds)

cirq-core/cirq/experiments/qubit_characterizations_test.py::test_parallel_single_qubit_parallel_single_qubit_randomized_benchmarking
  /app/cirq-core/cirq/experiments/qubit_characterizations_test.py:130: DeprecationWarning: parallel_single_qubit_randomized_benchmarking was used but is deprecated.
  It will be removed in cirq v2.0.
  please use parallel_single_qubit_rb instead

    results = parallel_single_qubit_randomized_benchmarking(

cirq-core/cirq/experiments/t1_decay_experiment_test.py::test_curve_fit_plot_works
  /app/cirq-core/cirq/experiments/t1_decay_experiment.py:145: RuntimeWarning: Optimal parameters could not be found for curve fit
    warnings.warn("Optimal parameters could not be found for curve fit", RuntimeWarning)

cirq-core/cirq/experiments/t1_decay_experiment_test.py::test_plot_does_not_raise_error
cirq-core/cirq/experiments/t1_decay_experiment_test.py::test_plot_does_not_raise_error
  /app/cirq-core/cirq/experiments/t1_decay_experiment.py:141: OptimizeWarning: Covariance of the parameters could not be estimated
    self.popt, _ = optimize.curve_fit(exp_decay, xs, probs, p0=[t1_guess, 1.0, 0.0])

cirq-core/cirq/circuits/qasm_output_test.py::test_qasm_global_pahse
  /app/cirq-core/cirq/ops/gate_operation.py:351: UserWarning: OpenQASM 2.0 does not support global phase.Since the global phase does not affect the measurement results, the conversion to QASM is disregarded.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec72-InsertStrategy-InsertStrategy]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec116-PauliSumExponential-PauliSumExponential]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec72-InsertStrategy-InsertStrategy]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec29-CircuitDiagramInfoArgs-CircuitDiagramInfoArgs]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec5-AxisAngleDecomposition-AxisAngleDecomposition]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec281-IonQSerializerMixedGatesetsException-IonQSerializerMixedGatesetsException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec274-Calibration-Calibration]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec0-Alignment-Alignment]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec280-IonQNotFoundException-IonQNotFoundException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec171-TextDiagramDrawer-TextDiagramDrawer]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec279-IonQException-IonQException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec158-SparseSimulatorStep-SparseSimulatorStep]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec87-LinearCombinationOfOperations-LinearCombinationOfOperations]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec288-SimulatorResult-SimulatorResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec137-QubitOrder-QubitOrder]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec44-DensityMatrixSimulator-DensityMatrixSimulator]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec137-QubitOrder-QubitOrder]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec46-DensityMatrixTrialResult-DensityMatrixTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec246-Sycamore23-GridDevice]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec28-CircuitDiagramInfo-CircuitDiagramInfo]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec171-TextDiagramDrawer-TextDiagramDrawer]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec45-DensityMatrixStepResult-DensityMatrixStepResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec286-QPUResult-QPUResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec163-StateVectorTrialResult-StateVectorTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec117-PeriodicValue-PeriodicValue]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec278-IonQAPIDevice-IonQAPIDevice]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec153-SimulationTrialResult-SimulationTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec46-DensityMatrixTrialResult-DensityMatrixTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec38-CliffordTrialResult-CliffordTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec51-ExpressionMap-ExpressionMap]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec31-CircuitSampleJob-CircuitSampleJob]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec117-PeriodicValue-PeriodicValue]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec125-PointOptimizationSummary-PointOptimizationSummary]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec51-ExpressionMap-ExpressionMap]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec132-QasmArgs-QasmArgs]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec115-PauliSumCollector-PauliSumCollector]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec284-Job-Job]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec35-CliffordSimulatorStepResult-CliffordSimulatorStepResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec278-IonQAPIDevice-IonQAPIDevice]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec175-Timestamp-Timestamp]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec132-QasmArgs-QasmArgs]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec28-CircuitDiagramInfo-CircuitDiagramInfo]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec281-IonQSerializerMixedGatesetsException-IonQSerializerMixedGatesetsException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec162-StateVectorMixin-StateVectorMixin]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec158-SparseSimulatorStep-SparseSimulatorStep]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec280-IonQNotFoundException-IonQNotFoundException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec125-PointOptimizationSummary-PointOptimizationSummary]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec80-KakDecomposition-KakDecomposition]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec44-DensityMatrixSimulator-DensityMatrixSimulator]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec5-AxisAngleDecomposition-AxisAngleDecomposition]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec136-QuantumState-QuantumState]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec31-CircuitSampleJob-CircuitSampleJob]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec29-CircuitDiagramInfoArgs-CircuitDiagramInfoArgs]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec115-PauliSumCollector-PauliSumCollector]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec87-LinearCombinationOfOperations-LinearCombinationOfOperations]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec175-Timestamp-Timestamp]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec133-QasmOutput-QasmOutput]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec133-QasmOutput-QasmOutput]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec288-SimulatorResult-SimulatorResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec179-TwoQubitGateTabulationResult-TwoQubitGateTabulationResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec86-LinearCombinationOfGates-LinearCombinationOfGates]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec279-IonQException-IonQException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec283-IonQUnsuccessfulJobException-IonQUnsuccessfulJobException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec153-SimulationTrialResult-SimulationTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec80-KakDecomposition-KakDecomposition]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec154-SimulationTrialResultBase-SimulationTrialResultBase]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec35-CliffordSimulatorStepResult-CliffordSimulatorStepResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec116-PauliSumExponential-PauliSumExponential]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec45-DensityMatrixStepResult-DensityMatrixStepResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec162-StateVectorMixin-StateVectorMixin]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec245-Sycamore-GridDevice]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec274-Calibration-Calibration]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec154-SimulationTrialResultBase-SimulationTrialResultBase]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec136-QuantumState-QuantumState]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec179-TwoQubitGateTabulationResult-TwoQubitGateTabulationResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec163-StateVectorTrialResult-StateVectorTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec38-CliffordTrialResult-CliffordTrialResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_json_test_data_coverage[mod_spec286-QPUResult-QPUResult]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec86-LinearCombinationOfGates-LinearCombinationOfGates]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec284-Job-Job]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec283-IonQUnsuccessfulJobException-IonQUnsuccessfulJobException]
FAILED cirq-core/cirq/protocols/json_serialization_test.py::test_type_serialization[mod_spec0-Alignment-Alignment]
= 82 failed, 19381 passed, 16 skipped, 8 xpassed, 100 warnings in 352.78s (0:05:52) =
